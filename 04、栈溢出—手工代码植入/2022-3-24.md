# 实验代码

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <WINDOWS.h>

#define PASSWORD "1234567"
int verify_password (char *password) 
{
	int authenticated;
	char buffer[44];
	authenticated=strcmp(password,PASSWORD);
	strcpy(buffer,password);//over flowed here!	
	return authenticated;
}

void main()
{
	int valid_flag=0;
	char password[1024];
	FILE * fp;
	LoadLibrary("user32.dll");
	if(!(fp=fopen("password.txt","rw+")))
	{
		exit(0);
	}
	fscanf(fp,"%s",password);
	valid_flag = verify_password(password);
	if(valid_flag)
	{
		printf("incorrect password!\n");
	}
	else
	{
		printf("Congratulation! You have passed the verification!\n");
	}
	fclose(fp);
}
```

这份代码与上一次实验相比又多了点改变，首先是LoadLibrary("user32.dll")，是为了后面调用user32.dll里面的MessageBox,然后就是buffer数组变大，目的是为了插入shellcode有足够的空间

# 实验操作

我们先在本地中插入shellcode，不考虑通用型，由于本地环境不会发生改变，所以MessageBoxA在每个进程中的地址都一样，我们可以直接利用vc6.0的工具Depend查看MessageBoxA的地址

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220324-205522@2x.png)

User32.dll的基址是0x77D10000

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220324-205553@2x.png)

MessageBoxA的偏移是0x000407EA

所以最终MessageBoxA在这台电脑上的地址为base+offset=0x77D10000+0x000407EA=0x77D507EA

注意MessageBox有两个版本，MessageBoxA和MessageBoxW，在xp中是MessageBoxA

## 构造shellcode

随便用OD打开一个程序，然后在空白区写汇编代码

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220324-210356@2x.png)

这里不直接使用push 0，是因为硬编码中会出现0，当我们读取password文件中的shellcode，其实是读取字符，这时候会把参数0误认为字符结束符从而结束读取

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220324-210651@2x.png)

将shellcode复制出来

33 DB 53 53 53 53 B8 EA 07 D5 77 FF D0

现在我们得找到返回地址，然后通过覆盖返回地址修改程序流程，跳转到我们的shellcode上

先给password填充一些垃圾数据，找到返回地址的位置

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220324-211248@2x.png)

在没有覆盖前，12FB24存放返回地址401118

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220324-211314@2x.png)

strcpy发生覆盖，可以看出覆盖返回地址的地方是klmn，现在需要将shellcode插入到文件中，然后被程序自己读取进去，并且将shellcode的地址覆盖到返回地址上

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220324-211902@2x.png)

红色的就是shellcode，但是我们此时还没有修改klmn位置上的返回地址，还得通过OD调试得到shellcode在栈中的地址，0x12FAF4，现在在010editor中将klmn位置改成12FAF4，注意小端存储，F4 FA 12 00

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220324-212534@2x.png)

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220324-212756@2x.png)

然后OD开始调试

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220324-212855@2x.png)

按我们所预料的，返回地址现在被覆盖成shellcode的入口

<img src="https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220324-212915@2x.png" style="zoom:50%;" />

由于我们没有填参数，只是一个简单的错误弹框，当然这里也没有处理后续操作，在执行完shellcode后就会报错

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220324-212934@2x.png)
