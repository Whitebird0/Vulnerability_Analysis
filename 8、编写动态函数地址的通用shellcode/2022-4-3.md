背景：
---
如果编写的ShellCode 采用了硬编址的方式来调用相应的API函数，这会存在操作系统的版本不一样，调用函数在内存中的地址不同而出现失败的现象，这时需要通过编写一些定位程序，让ShellCode 能够动态定位所需要的API函数地址，从中解决ShellCode 的通用性问题

弹窗程序中最重要的函数MessageBoxA，它是位于 User32.dll 这个动态链接库里，默认情况下是无法直接调用的，为了能够调用它，就需要调用LoadLibraryA函数来加载User32.dll模块，但LoadLibraryA又位于kernel32.dll链接库中

思路
---

所有的win32程序都会加载ntdll.dll和kerner32.dll这两个最基础的动态链接库。所以只要找到LoadLibraryA函数，就能加载任意动态链接库，并调用其它的函数。如何查找定位kernel32.dll动态链接库在前面一节已经说过了，这里不再重复描述。我们需要做的就是遍历kernel32.dll的导出表，找到LoadLibraryA函数，并调用它加载user32.dll,然后再遍历user32.dll的导出表，找到函数MessageBoxA。

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/master/20201128174329548.png)

这里借用别人博客的图片，描述的比较形象
```asm
void main(){
	_asm{
		nop                //用于区分编译器自动生成的汇编代码
		nop
		nop
		nop
		nop
		nop
		
		// 将要调用的函数hash值入栈保存
		
		CLD		  // 清空标志位DF
		push 0x1e380a6a   // 压入 MessageBoxA 字符串的hash
		push 0x4fd18963   // 压入 ExitProcess 字符串的hash
		push 0x0c917432   // 压入 LoadLibraryA 字符串的hash
		mov esi,esp	  // 指向栈中存放LoadLibraryA的hash地址
		lea edi,[esi-0xc] // 用于存放后边找到的三个函数地址
		
		// 开辟0x400大小的栈空间
		xor ebx,ebx
		mov bh,0x4
		sub esp,ebx

		// 将user32.dll入栈
		mov bx,0x3233	  // 压入字符 '32'
		push ebx
		push 0x72657375   // 压入字符 'user'
		push esp
		xor edx,edx

		// 查找 kernel32.dll 的基地址
		xor ebx,ebx
		mov ebx,fs:[0x30+edx]		// FS得到当前线程环境块TEB TEB+0x30 是进程环境块 PEB
		mov ecx,[ebx+0x0c]		// PEB+0x0c 是PEB_LDR_DATA结构体指针 存放这已经被进程加载的动态链接库的信息
		mov ecx,[ecx+0x1c]		// PEB_LDR_DATA+0x1c 指向模块初始化链表的头指针 InInitalizationOrderModuleList
		mov ecx,[ecx]			// 进入链表第一个就是ntdll.dll，往后移动一个就是kernel32.dll
		mov ebp,[ecx+0x8]		// 该链表其实是一个LDR_DATA_TABLE_ENTRY结构体，在InInitalizationOrderModuleList偏移+0x8的地方就是DllBase


		// 与 hash 的查找相关
find_lib_functions:

		lodsd				// 将[esi]中的4字节 传到eax中
		cmp eax,0x1e380a6a		//判断是否是MessageBoxA字符串的hash值
		jne find_functions		// 如果不相等则继续查找
		xchg eax,ebp			//保存hash值
		call [edi-0x8]			//此时栈顶是user32，直接调用LoadLibraryA("user32")
		xchg eax,ebp			//eax为user32的基址，再放回ebp

		// 在PE文件中查找相应的API函数
find_functions:
		pushad				// 保存寄存器环境
		mov eax,[ebp+0x3c]		// 指向PE头
		mov ecx,[ebp+eax+0x78]		// 得到导出表的指针，此时是偏移
		add ecx,ebp			// 得到导出函数表内存虚拟地址(VA)，也就是绝对地址
		mov ebx,[ecx+0x20]		// 得到导出函数名称表(RVA)
		add ebx,ebp			// 得到导出函数名称表内存虚拟地址(VA)，也就是绝对地址
		xor edi,edi		        // 初始化计数器
	
		// 循环遍历导出表函数
next_function_loop:
		inc edi				// 函数计数器+1
		mov esi,[ebx+edi*4]		// 得到当前函数名的地址(RVA)
		add esi,ebp		        // 得到当前函数名的内存虚拟地址(VA)
		cdq				//拓展

	       // 计算hash值
hash_loop:
		movsx eax,byte ptr[esi]		// 得到当前函数名称 第esi的一个字母
		cmp al,ah            	        // 比较到达函数名最后的0没有
		jz compare_hash			// 函数名hash计算完毕后跳到下一个流程
		ror edx,7	    	        // 循环右移7位
		add edx,eax			// 累加得到hash
		inc esi				// 计数+1 得到函数名的下一个字母
		jmp hash_loop			// 循环跳到 hash_loop

		// hash值的比较
compare_hash:
		cmp edx,[esp+0x1c]		// 比较目标函数名hash和当前函数名的hash
		jnz next_function_loop		// 如果不等于继续下一个函数名
		mov ebx,[ecx+0x24]		// 得到PE导出表中的函数序号列表的相对位置
		add ebx,ebp			// 得到PE导出表中的函数序号列表的绝对位置
		mov di,[ebx+2 * edi]		// 得到PE导出表中的当前函数的序号
		mov ebx,[ecx+0x1c]		// 得到PE导出表中的函数地址列表的相对位置
		add ebx,ebp			// 得到PE导出表中的函数地址列表的绝对位置
		add ebp,[ebx+4*edi]		// 得到PE导出表中的当前函数的绝对地址 
		
		// 循环依次得到kernel32.dll中的 LoadLibraryA  ExitProcess和user32.dll中的 MessageBoxA
		
		xchg eax,ebp			// 把函数地址放入eax中
		pop edi				// pushad中最后一个压入的是edi 正好是开始预留 用于存放的三个函数地址的栈空间
		stosd				// 把找到函数地址出入 edi对应的栈空间
		push edi			// 继续压栈 平衡栈
		popad				// 还原环境


		cmp eax,0x1e380a6a		// 比较是否是 MessageBoxA 函数 如果是说明全部函数已经找齐 可以调用函数执行功能
		jne find_lib_functions


function_call:
		xor ebx,ebx			// 将 ebx 清0
		push ebx		
		push 0x66666666			//MessageBoxA参数
		push 0x66666666			//MessageBoxA参数
		mov eax,esp			//eax指向字符串首地址
		push ebx			//依次压入MessageBoxA第四个参数
		push eax			//依次压入MessageBoxA第三个参数
		push eax			//依次压入MessageBoxA第二个参数
		push ebx			//依次压入MessageBoxA第一个参数
		call [edi-0x04]			//调用MessageBoxA
		push ebx			//ExitProcess参数0
		call [edi-0x8]		        //调用ExitProcess

		nop
		nop
		nop
		nop
		nop
		nop
		nop
	}
}
```
