```c
#pragma code_seg("shell")
#pragma comment(linker,"/entry:whitebird")
#include<windows.h> 

typedef FARPROC (WINAPI *myGetProcAddress)(HMODULE hModule,LPCSTR  lpProcName);
typedef HMODULE (WINAPI *myLoadLibraryExA)(LPCSTR lpLibFileName,HANDLE hFile,DWORD  dwFlags);
typedef void (WINAPI *myExitProcess)(UINT uExitCode);
typedef int (WINAPI *myMessageBoxA)(HWND   hWnd,LPCSTR lpText,LPCSTR lpCaption,UINT   uType);
void whitebird(){
	//kernel32.dll
	DWORD dwKernel32Addr=0;
	_asm{
		push eax
		mov eax,dword ptr fs:[0x30]
		mov eax,[eax+0xc]
		mov eax,[eax+0x1c]
		mov eax,[eax]
		mov eax,[eax+0x8]
		mov dwKernel32Addr ,eax
		pop eax
	}
	
	//GetProcAddress
	DWORD dwAddrBase=dwKernel32Addr;
	//DOS NT
	PIMAGE_DOS_HEADER pDos_Header;
	PIMAGE_NT_HEADERS pNt_Header;
	pDos_Header=(PIMAGE_DOS_HEADER)dwAddrBase;
	pNt_Header=(PIMAGE_NT_HEADERS)(dwAddrBase+pDos_Header->e_lfanew);

	PIMAGE_DATA_DIRECTORY pDataAdddr;
	PIMAGE_EXPORT_DIRECTORY pExport;
	pDataAdddr=pNt_Header->OptionalHeader.DataDirectory+IMAGE_DIRECTORY_ENTRY_EXPORT;
	pExport=(PIMAGE_EXPORT_DIRECTORY)(dwKernel32Addr+pDataAdddr->VirtualAddress);

	PDWORD pAddrOfFun=(PDWORD)(pExport->AddressOfFunctions+dwAddrBase);
	PDWORD pAddrOfName=(PDWORD)(pExport->AddressOfNames+dwAddrBase);
	PWORD pAddrOfOrdinals=(PWORD)(pExport->AddressOfNameOrdinals+dwAddrBase);
	
	DWORD dwFunAddr;
	for(DWORD i=0;i<pExport->NumberOfNames;i++){
		PCHAR lpFunName=(PCHAR)(pAddrOfName[i]+dwAddrBase);
		DWORD digest=0;
		while(*lpFunName){
			digest=((digest<<25)|(digest>>7));
			digest+=*lpFunName;
			lpFunName++;
		}
		if(digest==0xbbafdf85){
			dwFunAddr=pAddrOfFun[pAddrOfOrdinals[i]]+dwAddrBase;
			break;
		}		
}
	//LoadLibraryExA;
	char szLoadLibraryExA[]={'L','o','a','d','L','i','b','r','a','r','y','E','x','A','\0'};
	//user32.dll
	char szUser32dll[]={'u','s','e','r','3','2','.','d','l','l','\0'};
	//MessageBoxA
	char szMessageBox[]={'M','e','s','s','a','g','e','B','o','x','A','\0'};
	//ExitProcess
	char szExitProcess[]={'E','x','i','t','P','r','o','c','e','s','s','\0'};
	myGetProcAddress pmyGetProcAddress=(myGetProcAddress)dwFunAddr;
	myLoadLibraryExA pmyLoadLibraryExA=(myLoadLibraryExA)pmyGetProcAddress((HMODULE)dwAddrBase,szLoadLibraryExA);
	myExitProcess  pmyExitProcess=(myExitProcess)pmyGetProcAddress((HMODULE)dwAddrBase,szExitProcess);
	HMODULE dwuser32=pmyLoadLibraryExA(szUser32dll,NULL,NULL);
	myMessageBoxA pmyMessageBoxA=(myMessageBoxA)pmyGetProcAddress((HMODULE)dwuser32,szMessageBox);
	char white[]={'w','h','i','t','e','b','i','r','d','\0'};
	pmyMessageBoxA(NULL,white,white,MB_OK);
	pmyExitProcess(0);
}
```

这里注意两个点：
---

1、字符串必须得用数组存放，不能用指针，因为我们的shellcode要进行移植的，如果使用char* 那字符串就会存放在程序的常量区，此时进行shellcode移植时，并不会把字符串也带走，就会出现找不到字符串的情况

2、我们首先需要遍历kernel32.dll的导出表，找到GetProcAddress函数，这样后面就不需要重复造轮子了
