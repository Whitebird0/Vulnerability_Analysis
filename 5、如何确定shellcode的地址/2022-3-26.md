# 前言

我们知道ret是指向shellcode头部的，但是shellcode是存储在栈中的，我们现在的环境每次调试，栈的地址并没有发生改变，但是当我们遇到栈地址是动态时，这种写死地址的方法就会失效，所以这节我们学习一种新的思路。

# 实验

我们知道ret下面通常情况下是调用函数的栈顶esp，当我们ret后，我们的esp就会指向这，此时如果我们使用了JMP ESP指令，改变程序的执行流程，这时候程序就会指向esp指向的地方，我们如果在这里写入shellcode，就可以实现无需写死地址就能执行shellcode。

但是，我们如果自己实现JMP ESP，那就回到了问题的开始，这条指令也是动态的，所以我们得利用程序中的JMP ESP指令，因此我们从user32.dll 寻找JMP ESP指令，其机器码为FFE4.



![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220326-225443@2x.png)

返回地址是12FAF4，此时的shellcode在返回地址上方，如果我们把返回地址覆盖成JMP ESP，等执行完JMP ESP，程序就会走到12FB28，此时就避免了固定地址失效的问题。而shellcode的写入无非是输入的大小，输入的大小足够大就可以覆盖到返回地址下面



# 获取JMP ESP

我们需要的JMP ESP指令来自程序内部，可以通过遍历模块来获得，这里以user32.dll为例

```
#include<stdio.h>
#include<stdlib.h>
#include<windows.h>
#define DLL_NAME "user32.dll"

int main(){
	HINSTANCE hHandle=LoadLibrary(DLL_NAME);//加载dll
	if(!hHandle){
		exit(0);
	}
	BYTE * ptr=(BYTE*)hHandle;//handle就是模块基址
	BOOL flag=false;
	for(int i=0;!flag;i++){
		if(ptr[i]==0xFF&&ptr[i+1]==0xE4)//判断是否是JMP ESP指令
		{
		int address=(int )ptr+i;//基址+偏移
		printf("jmp esp address:%X",address);//打印
		flag=true;
		}
	}
	return 0;
}
```

这里我们可以将遍历到的地址打印出来，当然这条指令在dll中肯定不止一条，可以获得很多条地址不同的JMP ESP

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220326-232913@2x.png)

我们就以第一个为例，0x77D93AC4，没修改前 

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220326-235507@2x.png)

修改后

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220326-235901@2x.png)

紧跟返回地址的就是shellocode，这时候shellcode就从esp开始覆盖，当我们走完ret时，EIP被设置成0x77D93AC4，执行JMP ESP，然后又跳到shellcode首部，弹出MessageBox。

# 完善

由于我们没有处理后续操作，当程序弹完框之后就不知道后面的流程怎么走，我们可以让它返回到原来程序继续执行，也可以直接用ExitProcess()API退出程序

ExitProcess()API的查找方法与前面的MessageBox函数地址查找方法一样，只不过ExitProcess()在kernel32.dll里面

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220327-000842@2x.png)

获取基址为0x7C800000

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220327-000902@2x.png)

获取偏移为0x1CAFA

计算获得本机ExitProcess地址为0x7C800000+0x1CAFA=0x7C81CAFA

 另外，之前的弹框都是显示错误，没那么好看，我们稍微添加点内容，因此我们要重新编写shellcode

 ![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220327-002235@2x.png)

复制到010editor

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220327-003305@2x.png)

现在我们重新运行一下程序试试

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220327-003316@2x.png)

成功弹框并且成功退出，没有报错。
