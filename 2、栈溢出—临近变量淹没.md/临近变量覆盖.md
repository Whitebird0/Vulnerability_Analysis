# 实验代码

```
#include <stdio.h>
#include <string.h>

#define PASSWORD "1234567"
int verify_password (char *password)
{
	int authenticated;
	char buffer[8];// add local buff
	authenticated=strcmp(password,PASSWORD);
	strcpy(buffer,password);//over flowed here!	
	return authenticated;
}


int main()
{
	int valid_flag=0;
	char password[1024];
	while(1)
	{
		printf("please input password:       ");
		
		scanf("%s",password);
		
		valid_flag = verify_password(password);
		
		if(valid_flag)
		{
			printf("incorrect password!\n\n");
		}
		else
		{
			printf("Congratulation! You have passed the verification!\n");
			break;
		}
	}
	return 0;
}
```

这份代码中在verify_password函数内部申请了两个局部变量authenticated、buffer

当我们输入123456时，与正确密码不符合，会显示incorrect password!，此时程序正常执行

当我们输入1234567，与正确密码符合，显示Congratulation，也是正常执行

但是我们输入12345678，或者其他八位密码，都会显示正确，但是9位密码就错误了，与预期不符

# 原理分析

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220321-091418@2x.png)

先分析一下main函数，就是用一块缓冲区存放输入，然后将输入作为00401014的参数传入

# 函数00401014分析

我们输入12345678，然后进入函数内部分析

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220321-105014@2x.png)

eax返回值是1，说明比较后不匹配，也就是密码错误，此时ebp-4是局部变量，存放着比较后的返回值,继续分析

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220321-105539@2x.png)

这里的操作就是将我们输入的password通过函数strcpy复制给局部变量[ebp-c]，我们发现[ebp-c]与[ebp-4]两个局部变量非常接近，中间间隔8个字节，在没执行strcpy之前查看堆栈

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220321-105234@2x.png)

12FB24是EBP,12FB20是EBP-4，而12FB18是EBP-C，现在执行strcpy

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220321-110025@2x.png)

可以看到12FB18开始八个字节由于小段存储，已经将12345678存入，但是12FB20的EBP-4，也就是我们的strcmp返回值变成了0，这样子当这个函数结束后，返回值从1变成了0，从而导致我们输入任意八位密码都会正确

## 原因

12345678是字符串，在结尾会有个‘0’，当密码把局部变量缓冲区占满后，最后的0刚好将返回值给覆盖成0了，从而导致程序的错误执行。
