# 前言

首先我们知道定位函数地址需要两个函数(LoadLibrary，GetProcAddress),而这两个函数是在Kernel32.dll中的，所以我们要先找到Kernel32.dll的地址

# 方法

## 查找

[TEB+0x30] =  PEB的首地址

[PEB+0xC] =  PEB_LDR_DATA地址

[PEB_LDR_DATA+0x1C]  = 模块初始化链表头指针,ListEntry结构体

Flink 指向下一个结构

Blink 指向上一个结构

## 注意

Windows操作系统中:

第一个节点通常是ntdll.dll模块

第二个节点通常是Kernel32.dll模块(或者是KernelBase.dll) 

 [PEB_LDR_DATA+0x1C] 指向链表头指针是结构体_LDR_DATA_TABLE_ENTRY中偏移0x10的成员

## 操作

首先随便打开一个进程，我这里打开了Ollydbg.exe

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/master/QQ截图20220403164459.png)

通过指令.process /i 86cb8030 切换进程

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/master/QQ截图20220403164818.png)

然后我们需要获取PEB之前要的到TEB

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/master/QQ截图20220403164905.png)

FS寄存器通常情况下指向TEB，可以用指令直接获取PEB

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/master/QQ截图20220403165144.png)

dt _PEB 7ffdf000 读取PEB结构体

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/master/QQ截图20220403165257.png)

dt _PEB_LDR_DATA 0x77c87880 查看 LDR指向的结构体

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/master/QQ截图20220403165346.png)

我们需要关注的是偏移为0x1C的 InInitializationOrderModuleList双向链表

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/master/QQ截图20220403165919.png)

我们用结构体_LDR_DATA_TABLE_ENTRY去解析，发现DllName都不正确，这是因为0x006f1b98指向偏移0x10的位置，从这个地方开始解析肯定是不正确的，需要-0x10，因此真正的解析指令是dt _LDR_DATA_TABLE_ENTRY  (0x006f1b98 -0x10)

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/master/QQ截图20220403170110.png)

我们也可以看到下一个链表地址 是0x6f2088

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/master/QQ截图20220403170525.png)

找到了kernel32.dll地址，并且链表的上一个结点地址也可以对应上，DllBase为0x75DD0000

