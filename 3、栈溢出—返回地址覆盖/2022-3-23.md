# 栈溢出—返回地址覆盖

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define PASSWORD "1234567"
int verify_password (char *password)
{
	int authenticated;
	char buffer[8];
	authenticated=strcmp(password,PASSWORD);
	strcpy(buffer,password);//over flowed here!	
	return authenticated;
}
void main()
{
	int valid_flag=0;
	char password[1024];
	FILE * fp;
	if(!(fp=fopen("password.txt","rw+")))
	{
		exit(0);
	}
	fscanf(fp,"%s",password);
	valid_flag = verify_password(password);
	if(valid_flag)
	{
		printf("incorrect password!\n");
	}
	else
	{
		printf("Congratulation! You have passed the verification!\n");
	}
	fclose(fp);
}
```

我们在上节实验中已经学习了临近变量的覆盖，其实返回地址也是可以覆盖的

这里我们的输入是通过文件输入的，因为我们修改地址时是十六进制的，直接输入的是ascii码，所以文本操作更方便，后面实验中就能体会到。

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220323-214401@2x.png)

# 分析函数401005

主函数除了输入的改变，其他和上一节实验都是一样的，我们分析401005函数，虽然代码没有发生改变，但是我们这节研究的对象是返回值

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220323-220219@2x.png)

先观察堆栈，此时栈里先压入了参数，然后把call 指令的下一条指令地址压入栈

由于函数内部会有堆栈的提升，我们看一下新堆栈

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220323-220553@2x.png)

401104上面就是新的栈底，

EBP-4存放的是一个局部变量，记录strcmp的结果，在上一节中我们就是覆盖的它

EBP-C存放的是一个数组，是strcpy的目的地，通过加长它的长度就能将EBP-4覆盖

假如我们将输入变得很长，那么是有可能将返回地址覆盖掉，通过这种方法，我们如果将返回地址覆盖成其他地址，就可以改变程序的执行流程，当然，如果地址不合法也会出现程序奔溃。

我们修改password.txt，改为123456733333333333333333333333

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220323-221256@2x.png)

返回值变成了33333333，F9运行，程序会崩溃

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220323-221451@2x.png)

# 通过修改Ret篡改程序执行流程

既然返回地址覆盖由我们的输入决定，我们就可以直接将密码验证正确的地址赋给返回地址，达到无论密码是否正确，都会跳到congratulation，这样就实现了程序流程的篡改

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220323-221815@2x.png)

我们得到想要跳到的地址为0x0040111F,数据存储在计算机中是小端存储，但是ret的时候，EIP是直接读取栈中的数据，所以我们在输入地址的时候也得先用小端存储的方式输入，即1F 11 40 00

我们直接输入程序的数据是ascii码，比如1就是0x31，2就是0x32，但是文件本身是二进制文件，我们可以通过010editor来修改相应位置成十六进制地址，这也就是前面说通过文件输入的好处。

既然知道了要插入的地址，现在还得解决的问题就是插在哪？

我们可以通过先随便输入数据，最好是不一样的，比如123456789abcdefghijgklmnopqrstuvwxyz，然后观察堆栈，可以知道哪一块数据是对应覆盖返回地址的，然后替换就行了

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220323-222601@2x.png)

小端存储68696A6B，对应ascii字符就是hijk,用010打开password文件，然后转16进制查看

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220323-223243@2x.png)

修改后

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220323-223308@2x.png)

现在重新调试

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220323-223544@2x.png)

现在12FB24地址存的就是我们设置的返回地址，当这个函数执行完，40111F就会被当成返回值放到EIP中

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220323-223733@2x.png)

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ20220323-223750@2x.png)